# 전화번호 목록

### 문제 설명

전화번호부에 적힌 전화번호 중, 한 번호가 다른 번호의 접두어인 경우가 있는지 확인하려 합니다.

전화번호가 다음과 같을 경우, 구조대 전화번호는 영석이의 전화번호의 접두사입니다.

- 구조대 : 119
- 박준영 : 97 674 223
- 지영석 : 11 9552 4421

전화번호부에 적힌 전화번호를 담은 배열 phone_book 이 solution 함수의 매개변수로 주어질 때, 어떤 번호가 다른 번호의 접두어인 경우가 있으면 false를 그렇지 않으면 true를 return 하도록 solution 함수를 작성해주세요.

<br/>

### 제한 사항

- phone_book의 길이는 1 이상 1,000,000 이하입니다.
    - 각 전화번호의 길이는 1 이상 20 이하입니다.
    - 같은 전화번호가 중복해서 들어있지 않습니다.

<br/>

### 입출력 예

| phone_book | return |
| --- | --- |
| ["119", "97674223", "1195524421"] | false |
| ["123","456","789"] | true |
| ["12","123","1235","567","88"] | false |

<br/>

### 📕 문제 포인트 (첫 번째)

1. 한 번호가 다른 번호의 접두사 인지 체크하려면 **전화번호의 길이가 긴 번호 부터 전화번호의 길이가 짧은 번호를 찾아야 된다**고 생각했습니다.
    - sort() 사용 - O(n log n)의 시간 복잡도
2. **접두어를 발견하면 즉시 false를 return**하고 그게 아니라면 마지막까지 순회 후 true를 리턴하는 형식으로 구현하였습니다.
3. 같은 번호는 중복해서 들어있지 않기 때문에 new Set을 사용할 필요가 없습니다.

```jsx
function solution(phone_book) {
    phone_book.sort((a,b) => b - a); // 내림차순 정렬
    let map = new Map();
    for(const phoneNumber of phone_book) {
        let phone = ""; // 저장할 번호
        for(let i=0;i<phoneNumber.length;i++) {
            phone += phoneNumber[i];
            if(i === phoneNumber.length - 1 && map.has(phone)) {
                return false;
            }
            map.set(phone, true);
        }
    }
    return true;
}
```

<br/>

**효율성  테스트**

테스트 1 〉통과 (49.11ms, 50.2MB)<br/>
테스트 2 〉통과 (49.54ms, 50.7MB)<br/>
테스트 3 〉통과 (1039.82ms, 118MB)<br/>
테스트 4 〉통과 (1920.71ms, 204MB)

<br/>

### 📕 문제 포인트 (두 번째)

효율성이 너무 낮게 나오고 이중 for문을 사용해서 풀다 보니..O(n^2) 시간 복잡도가 걸려서 더 빠른 방법이 없나 고민하다. AI에게 물어보니 제가 생각한 거랑 비슷한데 정렬의 핵심이 달랐습니다.

1. phone_book을 sort()를 이용하여 사전순 정렬해 줍니다.
2. 이후 정렬된 순서대로 for문을 돌며 현재 전화번호의 한 칸 앞 전화번호에 내 전화번호가 접두사로 있는지 확인합니다.
3. 전화번호가 존재한다면 그 순간 return false를 전달합니다.
4. 이렇게 처리가 가능한 이유는 사전 순으로 정렬을 하다 보니, 현재 나의 전화번호가 내 앞사람에게 포함되어 있지 않다면 나의 전화번호가 접두사인 경우는 없습니다.
5. 이러한 과정을 통해 효율적인 코드를 작성할 수 있습니다.

```jsx
function solution(phone_book) {
    phone_book.sort(); // 사전순으로 정렬

		// 마지막 전화번호는 비교할 전화번호가 없으므로 체크할 필요가 없습니다.
    for(let i = 0; i < phone_book.length - 1; i++) {
				// 전화번호의 바로 앞 전화번호에 접두어로 포함되어 있는지 체크
				// String.startsWith();
				// => 대상 문자열이 주어진 문자로 시작하면 true, 아니면 false 
				// 두 번째 매개변수로는 탐색할 index 위치가 들어오고 기본값은 0 입니다.
        if(phone_book[i+1].startsWith(phone_book[i])) {
            return false;
        }
    }
    return true;
}
```
<br/>

**효율성  테스트**

테스트 1 〉통과 (4.16ms, 35.2MB)<br/>
테스트 2 〉통과 (3.82ms, 35.2MB)<br/>
테스트 3 〉통과 (133.36ms, 79MB)<br/>
테스트 4 〉통과 (105.27ms, 76.2MB)


<br/>


### 📕 문제 포인트 (마지막)
꼭 정렬을 사용하지 않고 `Hash`를 이용하여 문제를 풀 수 있다는 규칙을 찾아 코드를 수정해 봤다.
1. map을 만들어 먼저 모든 전화번호를 `map`에 넣는다.
2. 이후 전화번호 리스트를 순회하면서 `phoneNumber` 변수에 번호를 하나씩 더해가며 해당 번호가 `map`에 있는지 확인한다.
    - 여기서 중요한 점은, phone.length - 1까지만 순회한다는 점이다. (이유는 phone.length까지 돌게 되면 자기 자신을 만나게 돼 무조건 `map.has(phoneNumber)`에 걸리게 된다.)
    - 만약 `map.has(phoneNumber) === ture` 가 되면 접두사인 전화번호가 있으므로 바로 return false를 한다.
    - 끝까지 순회해도 접두사인 전화번호가 없다면 return true 처리한다. 
```js
function solution(phone_book) {
    let map = new Map();
    phone_book.forEach(phone => map.set(phone, 1));
    
    for(const phone of phone_book) {
        let phoneNumber = "";
        for(let i=0;i<phone.length - 1;i++) {
            phoneNumber += phone[i];
            if(map.has(phoneNumber)) return false;
        }
    }
    
    return true;
}
```

<br/>

**효율성 테스트**

테스트 1 〉	통과 (1.38ms, 35.7MB)<br/>
테스트 2 〉	통과 (1.35ms, 35.8MB)<br/>
테스트 3 〉	통과 (380.96ms, 98.6MB)<br/>
테스트 4 〉	통과 (241.82ms, 94MB)
