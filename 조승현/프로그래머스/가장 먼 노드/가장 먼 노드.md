# κ°€μ¥ λ¨Ό λ…Έλ“

[λ¬Έμ  λ§ν¬](https://school.programmers.co.kr/learn/courses/30/lessons/49189)

### λ¬Έμ μ„¤λ…

nκ°μ λ…Έλ“κ°€ μλ” κ·Έλν”„κ°€ μμµλ‹λ‹¤. κ° λ…Έλ“λ” 1λ¶€ν„° nκΉμ§€ λ²νΈκ°€ μ ν€μμµλ‹λ‹¤. 1λ² λ…Έλ“μ—μ„ κ°€μ¥ λ©€λ¦¬ λ–¨μ–΄μ§„ λ…Έλ“μ κ°―μλ¥Ό κµ¬ν•λ ¤κ³  ν•©λ‹λ‹¤. κ°€μ¥ λ©€λ¦¬ λ–¨μ–΄μ§„ λ…Έλ“λ€ μµλ‹¨κ²½λ΅λ΅ μ΄λ™ν–μ„ λ• κ°„μ„ μ κ°μκ°€ κ°€μ¥ λ§μ€ λ…Έλ“λ“¤μ„ μλ―Έν•©λ‹λ‹¤.

λ…Έλ“μ κ°μ n, κ°„μ„ μ— λ€ν• μ •λ³΄κ°€ λ‹΄κΈ΄ 2μ°¨μ› λ°°μ—΄ vertexκ°€ λ§¤κ°λ³€μλ΅ μ£Όμ–΄μ§ λ•, 1λ² λ…Έλ“λ΅λ¶€ν„° κ°€μ¥ λ©€λ¦¬ λ–¨μ–΄μ§„ λ…Έλ“κ°€ λ‡ κ°μΈμ§€λ¥Ό return ν•λ„λ΅ solution ν•¨μλ¥Ό μ‘μ„±ν•΄μ£Όμ„Έμ”.

<br/>

### μ ν•μ‚¬ν•­

- λ…Έλ“μ κ°μ nμ€ 2 μ΄μƒ 20,000 μ΄ν•μ…λ‹λ‹¤.
- κ°„μ„ μ€ μ–‘λ°©ν–¥μ΄λ©° μ΄ 1κ° μ΄μƒ 50,000κ° μ΄ν•μ κ°„μ„ μ΄ μμµλ‹λ‹¤.
- vertex λ°°μ—΄ κ° ν–‰ [a, b]λ” aλ² λ…Έλ“μ™€ bλ² λ…Έλ“ μ‚¬μ΄μ— κ°„μ„ μ΄ μλ‹¤λ” μλ―Έμ…λ‹λ‹¤.

<br/>

### ****μ…μ¶λ ¥ μ****

| n | vertex | return |
| --- | --- | --- |
| 6 | [[3, 6], [4, 3], [3, 2], [1, 3], [1, 2], [2, 4], [5, 2]] | 3 |

<br/>

### π“• λ¬Έμ  ν¬μΈνΈ

1. 1λ² λ…Έλ“λ¶€ν„° μ‹μ‘ν•μ—¬ **κ°„μ„  μ¤‘ κ°€μ¥ λ©€λ¦¬ λ–¨μ–΄μ§„ λ…Έλ“μ κ°μ**λ¥Ό μ°Ύλ” λ¬Έμ 
    - κ° μ μλ” κ²½λ΅ μ¤‘ μµλ‹¨ κ²½λ΅λ¥Ό κΈ°μ¤€μΌλ΅ μ°Ύλ”λ‹¤.
2. **μ–‘λ°©ν–¥ κ·Έλν”„**μ΄λ‹¤. (ex) 1β†’ 2 / 2 β†’ 1 μ„λ΅ μ΄λ™ κ°€λ¥)
    - μ–‘λ°©ν–¥ κ·Έλν”„ - **2μ°¨μ› λ°°μ—΄**
3. **μ΄λ―Έ λ°©λ¬Έν• λ…Έλ“λ” λ‹¤μ‹ λ°©λ¬Έν•κ±°λ‚ κ±°λ¦¬λ¥Ό μ°Ύμ„ ν•„μ”κ°€ μ—†λ‹¤.**

```javascript
function solution(n, edge) {
    let vertex = Array.from({length:n+1}, () => []); // nκ°μ 2μ°¨μ› λ°°μ—΄μ„ μƒμ„±
    let ch = Array.from({length:n+1}, () => 0);      // κ±°λ¦¬λ¥Ό κΈ°λ΅ν•  check λ°°μ—΄
    ch[1] = 1; // 1λ² λ…Έλ“λ΅ λ¶€ν„° μ¶λ°
    
		// λ°°μ—΄μ— μ΄λ™ κ°€λ¥ λ…Έλ“ λ‹΄κΈ°
    for(const [x,y] of edge) {
        vertex[x].push(y);
        vertex[y].push(x);
    }
    
    let queue = [];
    for(let i=0;i<vertex[1].length;i++) {
				// 1λ²μ—μ„ μ²μ κ° μ μλ” λ…Έλ“ λ°°μ—΄μ— λ―Έλ¦¬ λ‹΄κΈ°
        queue.push({key: 1, value:vertex[1][i]}) // keyλ” μ¶λ° λ…Έλ“ / valueλ” λ„μ°© λ…Έλ“
    }
    
    while(queue.length > 0) {
        let {key, value} = queue.shift();
				// ν•λ²λ„ λ°©λ¬Έν•μ§€ μ•μ•λ”μ§€ μ²΄ν¬ν•κΈ°
        if(ch[value] === 0) {
            ch[value] = ch[key] + 1;
            for(let k=0;k<vertex[value].length;k++) {
                const kValue = vertex[value][k];
                if(ch[kValue] === 0) {
                    queue.push({key: value, value: kValue});
                }
            }
        }
    }
    
    let max = Math.max(...ch);
    return ch.filter(num => num === max).length
}
```